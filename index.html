<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Star Crush ‚ú®üê±</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: linear-gradient(135deg, #0a0a2e 0%, #1a0a3e 50%, #0a0a2e 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden;
  touch-action: none;
}
#header {
  color: #fff; text-align: center; margin-bottom: 12px;
}
#header h1 { font-size: 28px; text-shadow: 0 0 20px rgba(255,200,50,0.8); }
#header h1 span { color: #ffcc00; }
#stats {
  display: flex; gap: 30px; justify-content: center; margin: 8px 0;
  color: #ccc; font-size: 16px;
}
#stats span { font-weight: bold; color: #fff; }
canvas {
  border-radius: 12px;
  box-shadow: 0 0 40px rgba(100,50,200,0.4), inset 0 0 60px rgba(0,0,0,0.3);
  background: rgba(10,10,40,0.8);
  cursor: pointer;
}
#message {
  color: #ffcc00; font-size: 20px; margin-top: 10px; height: 28px;
  text-shadow: 0 0 10px rgba(255,200,0,0.6);
}
</style>
</head>
<body>
<div id="header">
  <h1>‚≠ê <span>Star Crush</span> üêæ</h1>
  <div id="stats">
    Score: <span id="score">0</span> &nbsp;|&nbsp; Moves: <span id="moves">30</span> &nbsp;|&nbsp; Level: <span id="level">1</span>
  </div>
</div>
<canvas id="game"></canvas>
<div id="message"></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Responsive sizing
const isMobile = window.innerWidth < 500;
const COLS = 8, ROWS = 8;
const CELL = isMobile ? Math.floor((window.innerWidth - 20) / COLS) : 64;
const PAD = 4;
canvas.width = COLS * CELL;
canvas.height = ROWS * CELL;

// Game state
let grid = [];
let selected = null;
let score = 0;
let moves = 30;
let level = 1;
let animating = false;
let particles = [];
let combo = 0;

// Piece types with emoji and colors
const TYPES = [
  { name: 'star',    emoji: '‚ú®', color: '#FFD700', bg: '#5c4400' },
  { name: 'galaxy',  emoji: 'ü™ê', color: '#E040FB', bg: '#5a1a5a' },
  { name: 'comet',   emoji: '‚òÑÔ∏è', color: '#00BFFF', bg: '#003855' },
  { name: 'moon',    emoji: 'üåô', color: '#C0C0FF', bg: '#2e2e6a' },
  { name: 'fish',    emoji: 'üêü', color: '#4FC3F7', bg: '#1a4060' },
  { name: 'cat',     emoji: 'üê±', color: '#FF9800', bg: '#5a3500' },
];

function createPiece(col, row, type) {
  return { col, row, type: type ?? Math.floor(Math.random() * TYPES.length), y: row * CELL, targetY: row * CELL, alpha: 1, scale: 1 };
}

function initGrid() {
  grid = [];
  for (let c = 0; c < COLS; c++) {
    grid[c] = [];
    for (let r = 0; r < ROWS; r++) {
      let t;
      do {
        t = Math.floor(Math.random() * TYPES.length);
      } while (
        (c >= 2 && grid[c-1][r]?.type === t && grid[c-2][r]?.type === t) ||
        (r >= 2 && grid[c][r-1]?.type === t && grid[c][r-2]?.type === t)
      );
      grid[c][r] = createPiece(c, r, t);
    }
  }
}

function drawPiece(p) {
  if (!p) return;
  const x = p.col * CELL;
  const y = p.y;
  const t = TYPES[p.type];
  const s = p.scale || 1;
  const sz = CELL - PAD * 2;

  ctx.globalAlpha = p.alpha || 1;
  ctx.save();
  ctx.translate(x + CELL/2, y + CELL/2);
  ctx.scale(s, s);

  // Background tile
  ctx.fillStyle = t.bg;
  ctx.beginPath();
  ctx.roundRect(-sz/2, -sz/2, sz, sz, 8);
  ctx.fill();

  // Subtle glow
  if (p === selected) {
    ctx.shadowColor = t.color;
    ctx.shadowBlur = 15;
    ctx.strokeStyle = t.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-sz/2, -sz/2, sz, sz, 8);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Emoji
  ctx.font = `${Math.floor(CELL * 0.55)}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(t.emoji, 0, 2);

  ctx.restore();
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Grid bg
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      ctx.fillStyle = (c + r) % 2 === 0 ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.01)';
      ctx.fillRect(c * CELL, r * CELL, CELL, CELL);
    }
  }

  for (let c = 0; c < COLS; c++)
    for (let r = 0; r < ROWS; r++)
      if (grid[c][r]) drawPiece(grid[c][r]);

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function updateParticles() {
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    return p.life > 0;
  });
}

function spawnParticles(col, row, type) {
  const cx = col * CELL + CELL/2;
  const cy = row * CELL + CELL/2;
  const color = TYPES[type].color;
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    particles.push({
      x: cx, y: cy, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      size: 2 + Math.random()*3, life: 1, color
    });
  }
}

function getMatches() {
  const matched = new Set();
  // Horizontal
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS - 2; c++) {
      const t = grid[c][r]?.type;
      if (t == null) continue;
      if (grid[c+1][r]?.type === t && grid[c+2][r]?.type === t) {
        let e = c;
        while (e < COLS && grid[e][r]?.type === t) { matched.add(`${e},${r}`); e++; }
      }
    }
  }
  // Vertical
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS - 2; r++) {
      const t = grid[c][r]?.type;
      if (t == null) continue;
      if (grid[c][r+1]?.type === t && grid[c][r+2]?.type === t) {
        let e = r;
        while (e < ROWS && grid[c][e]?.type === t) { matched.add(`${c},${e}`); e++; }
      }
    }
  }
  return [...matched].map(s => { const [c,r] = s.split(',').map(Number); return {c,r}; });
}

function removeMatches(matches) {
  const pts = matches.length * 10 * (1 + combo * 0.5);
  score += Math.floor(pts);
  document.getElementById('score').textContent = score;

  matches.forEach(({c, r}) => {
    if (grid[c][r]) spawnParticles(c, r, grid[c][r].type);
    grid[c][r] = null;
  });

  if (combo === 1) showMessage('Nice! üî•');
  else if (combo === 2) showMessage('Amazing! ‚ö°');
  else if (combo >= 3) showMessage('STELLAR! üåü‚ú®');
}

function dropPieces() {
  let moved = false;
  for (let c = 0; c < COLS; c++) {
    let empty = 0;
    for (let r = ROWS - 1; r >= 0; r--) {
      if (!grid[c][r]) { empty++; }
      else if (empty > 0) {
        grid[c][r + empty] = grid[c][r];
        grid[c][r + empty].row = r + empty;
        grid[c][r + empty].targetY = (r + empty) * CELL;
        grid[c][r] = null;
        moved = true;
      }
    }
    for (let r = 0; r < empty; r++) {
      grid[c][r] = createPiece(c, r);
      grid[c][r].y = -(empty - r) * CELL;
      grid[c][r].targetY = r * CELL;
      moved = true;
    }
  }
  return moved;
}

function animateDrop() {
  return new Promise(resolve => {
    function tick() {
      let still = true;
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS; r++) {
          const p = grid[c][r];
          if (!p) continue;
          if (Math.abs(p.y - p.targetY) > 0.5) {
            p.y += (p.targetY - p.y) * 0.25;
            still = false;
          } else {
            p.y = p.targetY;
          }
        }
      }
      updateParticles();
      draw();
      if (still && particles.length === 0) resolve();
      else requestAnimationFrame(tick);
    }
    tick();
  });
}

async function processMatches() {
  combo = 0;
  while (true) {
    const matches = getMatches();
    if (matches.length === 0) break;
    combo++;
    removeMatches(matches);
    await sleep(150);
    dropPieces();
    await animateDrop();
    await sleep(100);
  }
  combo = 0;

  // Check for possible moves
  if (!hasMoves()) {
    showMessage('No moves! Shuffling... üîÄ');
    await sleep(800);
    shuffle();
    dropPieces();
    await animateDrop();
    await processMatches();
  }
}

function hasMoves() {
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      if (c < COLS-1) { swap(c,r,c+1,r); if(getMatches().length>0){swap(c,r,c+1,r);return true;} swap(c,r,c+1,r); }
      if (r < ROWS-1) { swap(c,r,c,r+1); if(getMatches().length>0){swap(c,r,c,r+1);return true;} swap(c,r,c,r+1); }
    }
  }
  return false;
}

function shuffle() {
  const pieces = [];
  for (let c = 0; c < COLS; c++)
    for (let r = 0; r < ROWS; r++)
      pieces.push(grid[c][r].type);
  // Fisher-Yates
  for (let i = pieces.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [pieces[i],pieces[j]] = [pieces[j],pieces[i]];
  }
  let i = 0;
  for (let c = 0; c < COLS; c++)
    for (let r = 0; r < ROWS; r++) {
      grid[c][r].type = pieces[i++];
    }
}

function swap(c1,r1,c2,r2) {
  const tmp = grid[c1][r1];
  grid[c1][r1] = grid[c2][r2];
  grid[c2][r2] = tmp;
  if(grid[c1][r1]){grid[c1][r1].col=c1;grid[c1][r1].row=r1;grid[c1][r1].targetY=r1*CELL;}
  if(grid[c2][r2]){grid[c2][r2].col=c2;grid[c2][r2].row=r2;grid[c2][r2].targetY=r2*CELL;}
}

async function animateSwap(c1,r1,c2,r2) {
  const p1 = grid[c1][r1], p2 = grid[c2][r2];
  return new Promise(resolve => {
    const frames = 10;
    let f = 0;
    const dx1 = (c2-c1)*CELL/frames, dy1 = (r2-r1)*CELL/frames;
    function tick() {
      f++;
      if (p1) { p1.y += dy1; }
      if (p2) { p2.y -= dy1; }
      draw();
      if (f < frames) requestAnimationFrame(tick);
      else {
        if(p1) p1.y = p1.row * CELL;
        if(p2) p2.y = p2.row * CELL;
        resolve();
      }
    }
    tick();
  });
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function showMessage(msg) {
  const el = document.getElementById('message');
  el.textContent = msg;
  setTimeout(() => { if (el.textContent === msg) el.textContent = ''; }, 1500);
}

function isAdjacent(c1,r1,c2,r2) {
  return (Math.abs(c1-c2) + Math.abs(r1-r2)) === 1;
}

// Input handling
let dragStart = null;

function getCellFromEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  const col = Math.floor((clientX - rect.left) / CELL);
  const row = Math.floor((clientY - rect.top) / CELL);
  if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return null;
  return { col, row };
}

async function handleSelect(col, row) {
  if (animating || moves <= 0) return;

  if (!selected) {
    selected = grid[col][row];
    draw();
    return;
  }

  const sc = selected.col, sr = selected.row;
  if (sc === col && sr === row) {
    selected = null;
    draw();
    return;
  }

  if (!isAdjacent(sc, sr, col, row)) {
    selected = grid[col][row];
    draw();
    return;
  }

  animating = true;
  selected = null;

  swap(sc, sr, col, row);
  await animateSwap(sc, sr, col, row);

  const matches = getMatches();
  if (matches.length === 0) {
    swap(sc, sr, col, row);
    await animateSwap(sc, sr, col, row);
    showMessage('No match! üòø');
    animating = false;
    return;
  }

  moves--;
  document.getElementById('moves').textContent = moves;

  await processMatches();

  if (moves <= 0) {
    showMessage(`Game Over! Score: ${score} üéâ`);
    setTimeout(() => {
      if (confirm(`Game Over! Score: ${score}\nPlay again?`)) {
        score = 0; moves = 30; level = 1;
        document.getElementById('score').textContent = 0;
        document.getElementById('moves').textContent = 30;
        document.getElementById('level').textContent = 1;
        initGrid();
        draw();
      }
    }, 500);
  }

  animating = false;
}

canvas.addEventListener('mousedown', e => {
  const cell = getCellFromEvent(e);
  if (cell) { dragStart = cell; }
});

canvas.addEventListener('mouseup', e => {
  const cell = getCellFromEvent(e);
  if (cell && dragStart) {
    if (dragStart.col === cell.col && dragStart.row === cell.row) {
      handleSelect(cell.col, cell.row);
    } else if (isAdjacent(dragStart.col, dragStart.row, cell.col, cell.row)) {
      if (!selected || (selected.col !== dragStart.col || selected.row !== dragStart.row)) {
        selected = grid[dragStart.col][dragStart.row];
      }
      handleSelect(cell.col, cell.row);
    }
  }
  dragStart = null;
});

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (cell) dragStart = cell;
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const col = Math.floor((touch.clientX - rect.left) / CELL);
  const row = Math.floor((touch.clientY - rect.top) / CELL);
  if (col < 0 || col >= COLS || row < 0 || row >= ROWS) { dragStart = null; return; }

  if (dragStart) {
    if (dragStart.col === col && dragStart.row === row) {
      handleSelect(col, row);
    } else if (isAdjacent(dragStart.col, dragStart.row, col, row)) {
      if (!selected || (selected.col !== dragStart.col || selected.row !== dragStart.row)) {
        selected = grid[dragStart.col][dragStart.row];
      }
      handleSelect(col, row);
    }
  }
  dragStart = null;
}, { passive: false });

// Swipe support
let touchStartPos = null;
canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  touchStartPos = { x: t.clientX, y: t.clientY };
}, { passive: true });

canvas.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });

// Init
initGrid();
draw();

// Background stars
const bgCanvas = document.createElement('canvas');
bgCanvas.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1;pointer-events:none;';
document.body.appendChild(bgCanvas);
const bgCtx = bgCanvas.getContext('2d');
bgCanvas.width = window.innerWidth;
bgCanvas.height = window.innerHeight;

const stars = Array.from({length: 80}, () => ({
  x: Math.random() * bgCanvas.width,
  y: Math.random() * bgCanvas.height,
  size: Math.random() * 2,
  speed: 0.2 + Math.random() * 0.5,
  twinkle: Math.random() * Math.PI * 2
}));

function drawBg() {
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
  stars.forEach(s => {
    s.twinkle += 0.02;
    const alpha = 0.3 + Math.sin(s.twinkle) * 0.3;
    bgCtx.fillStyle = `rgba(255,255,255,${alpha})`;
    bgCtx.beginPath();
    bgCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    bgCtx.fill();
  });
  requestAnimationFrame(drawBg);
}
drawBg();
</script>
</body>
</html>
